// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.8.0/contracts/proxy/utils/Initializable.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.8.0/contracts/access/OwnableUpgradeable.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/token/ERC20/IERC20.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/token/ERC20/utils/SafeERC20.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/security/ReentrancyGuard.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/proxy/utils/UUPSUpgradeable.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/utils/math/Math.sol";

contract LPStakingContractHybrid is Initializable, ReentrancyGuard, UUPSUpgradeable, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using Math for uint256;

    IERC20 public lpToken;
    IERC20 public rewardToken;

    uint256 public rewardRate; // Reward rate per second (in wei)
    uint256 public constant SECONDS_IN_A_YEAR = 365 days;
    uint256 public totalStaked;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;
    uint256 public constant DECIMALS = 1e18;
    uint256 public timelockDuration = 2 days; // To prevent front-running
    uint256 public lastAPRChange;

    mapping(address => uint256) public userStake;
    mapping(address => uint256) public userRewards;
    mapping(address => uint256) public userRewardPerTokenPaid;

    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount);
    event RewardClaimed(address indexed user, uint256 amount);
    event RewardRateChanged(uint256 newRewardRate);
    event EmergencyWithdrawal(address indexed owner, address token, uint256 amount);
    event EmergencyPaused(bool status);

    bool public paused;

    function initialize(address _lpToken, address _rewardToken, uint256 apr) external initializer {
        require(_lpToken != address(0) && _rewardToken != address(0), "Zero address");
        __Ownable_init();
        lpToken = IERC20(_lpToken);
        rewardToken = IERC20(_rewardToken);
        setAPR(apr);
        _transferOwnership(msg.sender);
        lastUpdateTime = block.timestamp;
        lastAPRChange = block.timestamp;
        paused = false;
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    function _updateReward(address account) internal {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = block.timestamp;

        if (account != address(0)) {
            userRewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
    }

    modifier notPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    function stake(uint256 amount) external nonReentrant notPaused {
        require(amount > 0, "Amount must be greater than 0");
        _updateReward(msg.sender);
        lpToken.safeTransferFrom(msg.sender, address(this), amount);

        userStake[msg.sender] += amount;
        totalStaked += amount;

        emit Staked(msg.sender, amount);
    }

    function unstake(uint256 amount) external nonReentrant notPaused {
        require(amount > 0, "Amount must be greater than 0");
        require(userStake[msg.sender] >= amount, "Insufficient stake");
        _updateReward(msg.sender);

        userStake[msg.sender] -= amount;
        totalStaked -= amount;

        lpToken.safeTransfer(msg.sender, amount);
        emit Unstaked(msg.sender, amount);
    }

    function claimRewards() external nonReentrant notPaused {
        _updateReward(msg.sender);
        uint256 reward = userRewards[msg.sender];
        require(reward > 0, "No rewards to claim");
        userRewards[msg.sender] = 0;
        rewardToken.safeTransfer(msg.sender, reward);

        emit RewardClaimed(msg.sender, reward);
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalStaked == 0) return rewardPerTokenStored;
        uint256 timeElapsed = block.timestamp - lastUpdateTime;
        return rewardPerTokenStored + (timeElapsed * rewardRate * DECIMALS) / totalStaked;
    }

    function earned(address account) public view returns (uint256) {
        return (userStake[account] * (rewardPerToken() - userRewardPerTokenPaid[account])) / DECIMALS + userRewards[account];
    }

    function withdrawERC20(address tokenAddress, uint256 amount) external onlyOwner {
        require(tokenAddress != address(lpToken) && tokenAddress != address(rewardToken), "Cannot withdraw staking or reward tokens");
        IERC20(tokenAddress).safeTransfer(msg.sender, amount);
        emit EmergencyWithdrawal(msg.sender, tokenAddress, amount);
    }

    function setAPR(uint256 apr) public onlyOwner {
        require(apr > 0, "APR must be greater than zero");

        if (msg.sender != owner()) {
            require(block.timestamp >= lastAPRChange + timelockDuration, "Timelock in effect");
        }
        _updateReward(address(0));
        rewardRate = (apr * DECIMALS) / SECONDS_IN_A_YEAR;
        lastAPRChange = block.timestamp;
        emit RewardRateChanged(rewardRate);
    }

    function emergencyPause(bool _paused) external onlyOwner {
        paused = _paused;
        emit EmergencyPaused(_paused);
    }

    function getAPR() public view returns (uint256) {
        return (rewardRate * SECONDS_IN_A_YEAR * 100) / DECIMALS;
    }
}

//_lpToken: 0xB2a9D1e702550BF3Ac1Db105eABc888dB64Be24E (LP Token Address)
//_rewardToken: 0x9e27f48659b1005b1abc0f58465137e531430d4b (LQX Token Address)
//apr: 1000 (Μπορείς να το αλλάξεις αργότερα)
//[Contract 0x8e47D0a54Cb3E4eAf3011928FcF5Fab5Cf0A07c3 Implementation Contract with proxy created]
//0x8129fc1c000000000000000000000000b2a9d1e702550bf3ac1db105eabc888db64be24e0000000000000000000000009e27f48659b1005b1abc0f58465137e531430d4b00000000000000000000000000000000000000000000000000000000000003e8
